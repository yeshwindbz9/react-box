# Reactive Notes from namaste JS

## Why React

React is a JavaScript library for building user interfaces that was developed by Facebook. The name “React” was chosen because it is meant to help developers build user interfaces that are fast and responsive, or “reactive”. The library was designed to “react” to changes in data. When data in a React application changes, the components that depend on that data are automatically updated, which allows for efficient and seamless updates to the user interface.

### Library vs Framework

A library is essentially a set of functions that you can call, these days usually organized into classes. Each call does some work and returns control to the client.

A framework embodies some abstract design, with more behavior built in. In order to use it you need to insert your behavior into various places in the framework either by subclassing or by plugging in your own classes. The framework's code then calls your code at these points.

### What's a CDN?

A Content Delivery Network (CDN) is a geographically distributed group of servers that caches content close to end users. A CDN allows for the quick transfer of assets needed for loading Internet content, including HTML pages, JavaScript files, stylesheets, images, and videos.

To use React in your project using CDN, you can add script tags to load the latest versions of React and ReactDOM from unpkg, which is a CDN service that hosts npm packages.

## React Essentials

### NPM's full form is censored

npm is not a node package manager! It does not have a fullform, yes it helps manage packages, but does not stand for node package manager. npm is the world's largest Software Registry. All the libraries and utilities that we need in a react/react project comes from npm.

- npm init: creates a package.json file that contains the confirguation for our npm app.
- npm install <package_name>: fetches and installs the package_name from npm.
  - npm i: shorthand for install.
  - npm install: without an argument, it will install all the required modules from package.json
  - types of dependencies we can install
    - dev dependency: required in a development phase
    - normal dependency: used in development and production
- npm uninstall <package_name>: used to uninstall the package_name from our app.

### what is the Package.json file

A package.json file is a manifest file for your React app that lists the packages and versions your project depends on.

- lists the packages your project depends on
- specifies versions of a package that your project can use.
  - ^ before version: will automatically update the package to the next minor version (preferred)
  - ~ before version: will automatically update the package to the next major version
- makes your build reproducible, and therefore easier to share with other developers.

### Package-lock.json is different than Package.json

package-lock.json is a file that is automatically generated by npm when it modifies either the node_modules tree or package.json file.

- It is used to keep track of the exact dependency tree at any given time (unlike package.json which has ^, ~ or \*)
- keeps a hash code to verify if the local and production version are using the same version of package. This means that you can guarantee the dependencies for other developers or prod releases, etc
- It also has a mechanism to lock the tree but generally will regenerate if package.json changes
- It describes which version of every single package you have installed, That’s why it’s so much longer than package.json

### node_modules: the home of all the project modules

node_modules is a directory that contains all the external dependencies of a React app. When you install a package using npm or yarn, it gets downloaded and stored in the node_modules directory. This directory is created by npm or yarn and is used to store all the packages that your app depends on.

The node_modules directory is not included in the version control system (such as Git) because it can be recreated from scratch at any time by running npm install or yarn install command, thus no need to upload the whole directory, just keep a copy of the package.json and package-lock.json file.

### NPX and how is it related to NPM?

npx is a tool for executing Node packages. <br>
npx is a command-line interface tool that comes with npm. It allows you to run an arbitrary command from an npm package, in a similar context as running it via npm run. You can specify multiple packages to be provided in the PATH of the executed command, and use different options and flags to customize the behavior

### Parcel

Parcel is a web application bundler that can be used to build single or multi-page React applications. It provides a first-class development experience with Fast Refresh and supports JSX, TypeScript, Flow, and many styling methodologies out of the box. [helps us build a production ready webpage]

- Dev Build
- Bundles all code - also can have different prod and development build
- Differential bundling - bundled for different platform (support old browsers)
- Local Server
- Hot Module Replacement
- File watching algorithm - C++
- Caching - gives faster build using caching
- Hashing - uses consistent hashing
- Image optimization (one of the constiliest operations when loading a page)
- Minification and Compression of files
- Diagnostics and Error handling
- Hosting on HTTPS
- Tree shaking - removes unused code

### Note:

- Bundler is used to package our app, create react app uses webpack and babel behind the scenes to bundle all out html, css and js files.
- A package can depend on other small packages, thus there can be multiple package dependencies in a project, this is known as transitive dependencies.
- every dependency inside node_modules directory has its own set of package.json and package-lock.json
- node_modules directory has a lot of libraries that are huge, these can be re-installed using package.json, so add /node_modules to .gitignore to ignore them
- CDN links are not a preferred way to get react into projects
  - it's a costly operation (network calls)
  - we have to update the url with a different version of react frequently (no version manager)
- React is not the only module that makes your webpage fast, it's also modules like Parcel. React and Parcel go hand in hand.
- npx parcel build index.html: builds a dev build
  - remember to remove main from package.json

## React Foundations

### React Elements

React elements are the smallest building blocks of React applications. They are plain JavaScript objects that describe what we want to appear on the screen. Unlike browser DOM elements, React elements are cheap to create and are not actual instances.

An element can be created using JSX or React without JSX. An element contains type and properties, where the type specifies the component type (for example, a Button) and its properties (for example, its color). An element can be as simple as a single tag or can contain other elements inside it.

_React elements are not html elements! When they are rendered to DOM they become html elements._

### JSX

JSX stands for JavaScript XML.

- It is a syntax extension of JavaScript that allows us to write HTML-like code in our JavaScript code.
- JSX makes it easier to write and add HTML in React.
- It allows us to write HTML elements in JavaScript and place them in the DOM without any createElement() and/or appendChild() methods.
- JSX converts HTML tags into React elements.

_JSX helps create react elements much easily_

- _JSX is not a part of React_ (makes react user friendly)
- _JSX is not Html inside Javascript_ (but is a syntax extension of js)
- _JSX does not create Html elements_ (but it creates react elements i.e. js Objects)

_JS Engine does not understand JSX code. It's a syntax extension. JSX is not JS!_
_Parcel uses Babel to parse the JSX code, it's transpiled by Babel before it reaches the js engine_

### Babel

Babel is a transpiler that allows developers to use future JavaScript in today’s browsers. It can convert the latest version of JavaScript code into the one that the browser understands. Babel is a widely used tool that can transpile js code into the code that today’s browser understands. If you are using React, you can use Babel with React to transpile the JSX code into simple React functions that can be understood by browsers.

What are transpilers? <br>
Transpilers are also known as source-to-source compilers. So in essence they are a subset of compilers which take in a source code file and convert it to another source code file in some other language or a different version of the same language.

### React Component

A React component is a reusable piece of code that describes a part of a user interface. It can be a button, a form, a header, or any other element that we want to display on the screen. Components are the building blocks of React applications, and they can be used to create complex user interfaces.

React components can be of two types: class based components (old method) and function based components (new method ).
Class components are defined using ES6 classes and have a state and lifecycle methods. Function components are defined using JavaScript functions and do not have a state or lifecycle methods. Function components are simpler and easier to write than class components.

Functional components must return a JSX element.

_We can use this component in another component or in the ReactDOM.render() method to render it on the screen_
_FC's are js function that returns a react element._
_Component Composition refers to nesting components inside one another._

React provides several measures to prevent cross-site scripting (XSS) attacks. By default, React escapes any values embedded in JSX before rendering them. This ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered 2. This helps prevent XSS attacks. Beside that, we also have dangerouslySetInnerHTML and Content Security Policy (CSP) to help with scripting attacks.

### Note:

- package.json has the scripts object that shows the command used to run the project
- to give a class to html elements in html use className, use CamelCase instead of kebab case
- multiline JSX code has to be wrapped inside round brackets!
- name react functional components starting with a capital letter!

## Start Codin with Foodin

_before starting any frontend project, the first step is to prototype and design a wireframe/mockup._

### Dynamically passing data between props

When it comes to passing data between components in React, there are several ways to achieve this. One of the most common ways is to use props.

To pass data between a parent component and a child component, you can create two components, one parent and one child. Then, you can import the child component in the parent component and return it. You can create a function and a button to trigger that function. Also, you can create a state using the useState Hook to manage the data. When the button is clicked, it will store the data in the state variable. Finally, you can pass the data as props when you are calling the child component.

In the child component, you can capture the data by using either functional or class components. If you are using a functional component, you can simply catch the data in the parameters. If you have a class component, you can use this.props to access the data.

_passing props to an argument is like passing arguments to a function._

### Config driven UI

A config-driven UI is a technique that allows developers to create dynamic and customizable user interfaces without hard-coding them. It uses a configuration file to define the layout and content of the UI components.

This approach is useful when developers need to render two types of UI: config-driven forms/UI and data-driven forms/UI.

In a typical scenario, interaction between the client and the server is done using forms, starting with login to payment forms. Most of these forms also get frequent updates as the requirements increase in terms of form validations, dropdown options, or design changes. As a result, the code gets polluted after every update, and sometimes it’s very hard to read the whole code. To avoid this situation, developers can create a schema of the form using a config object based on their requirements. They can then use this schema to render the form.

The concept is to create a renderer function that accepts this config and renders different components accordingly. The renderer function can render different types of HTML elements based on the requirements, such as input, dropdown, checkbox, radio buttons, and even an image.

_when using loop to render components it's a must to create a uninque key, this is to uniquely identify them on the Dom tree. using list index as keys are a bad practise._

### React.Fragment element

React.Fragment is a special syntax that lets you group a list of HTML elements without adding extra nodes to the DOM. It is useful for returning multiple child components from a single parent component without introducing any unnecessary markup in the rendered HTML. You can use <React.Fragment> or the shorthand syntax <> to create a fragment

### Virtual DOM and Reconcilation

The Virtual DOM is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM.

_think of Virtual DOM as a copy of original DOM tracked by react, they do not have actual dom elements, but they use objects(react elements) to represent the actual dom_

It is used in declarative web frameworks such as React, Vue.js, and Elm. Updating the virtual DOM is comparatively faster than updating the actual DOM (via JavaScript).

Reconciliation in React refers to the process of updating the user interface efficiently when the underlying data or state changes. It is an important concept because it allows React to minimize the number of updates to the actual DOM, improving performance and ensuring a responsive user interface.

_Reconciliation algorithm is also known as React Fiber_

When a component’s state changes, React has to verify whether it needs to update the DOM or not. It does this by creating a Virtual DOM and comparing it with the current DOM. The virtual DOM is a lightweight copy of the actual DOM that React keeps in memory. It is faster to update the virtual DOM than the actual DOM. React uses a diffing algorithm to compare the virtual DOM with the current DOM and update only the parts that have changed. This process is called reconciliation.

### React Fiber

React Fiber is an ongoing reimplementation of React’s core algorithm that was introduced in React 16. It is a complete rewrite of the React core and is aimed at improving the perceived performance for complex React applications. The goal of React Fiber is to increase its suitability for areas like animation, layout, and gestures.

## Hookin with our app Foodin

_react is fast, because it can perform quick DOM manipulations_

### Import and export in js

In JavaScript, there are two types of exports: named exports and default exports.

Named exports are used to export several values from a module. We can use the export keyword to export variables, functions, or classes. We can also use the export keyword before the declaration of the variable, function, or class to export it.

Default exports are used to export only one value from a module. We can use the export default syntax to export a single value from a module. We can also use the export default syntax with functions, classes, or variables.

- To import named exports, we can use the import keyword followed by the name of the exported value in curly braces. For example, import { myFunction } from './myModule.js'.
- To import a default export, we can use the import keyword followed by any name we choose. For example, import myFunction from './myModule.js'
- You can use both default and named imports together in JavaScript. For example, import defaultExport, { namedExport1, namedExport2 } from './module.js';
- import all the named exports of a module using the _ character. For example, import _ as myModule from './module.js';

### Hooks and State variable in React

In React, a state variable is an object that stores the property values of a component. The state object is where you store property values that belong to the component. When the state object changes, the component re-renders.

_whenever a state variable changes react will rerender the component_

In React, a hooks are normal utility js functions that lets you use state and other React features without writing a class. React provides several built-in hooks that you can use in your functional components. Here are some of the most commonly used hooks:

- useState: Lets you add state to your functional components using state variables
- useEffect: Lets you perform side effects in your functional components, such as fetching data from an API or updating the document title
- useContext: Lets you consume context in your functional components
- useRef: Lets you create a mutable reference that persists across renders
- useReducer: Lets you manage complex state logic in your functional components

### Config.js file in a project

config.js is a file that can be used to store static data that needs to be used all over the React application. It can be used to store data such as API URLs, environment variables, and other configuration data.

The config.js file can be used to define a global JavaScript object that can be accessed from any file in the application. This can be useful when you have multiple files that use the same configuration data.

## Connecting React Applications with Microservices

### Development Architecture: Monolith & Microservice Architecture

In web development, _monolithic architecture_ is a traditional software design pattern where a single application is built as a unified unit that is self-contained and independent from other applications. The term “monolith” refers to something large and glacial, which is an apt description of this type of architecture.

In a _monolithic architecture_, the entire application is built as a single unit with one codebase that couples all of the business concerns together. This makes it easier to manage code early on in a project’s life, but as the application grows, it can become difficult to maintain and scale. To make a change to this sort of application requires updating the entire stack by accessing the code base and building and deploying an updated version of the service-side interface. This makes updates restrictive and time-consuming.

In contrast, a _microservices architecture_ is a collection of smaller, independently deployable services that are built around business capabilities. Each service is self-contained and can be developed, deployed, and scaled independently. This makes it easier to manage and scale the application as it grows.

_Microservices communicate_ with other services through simple interfaces to solve business problems. This architecture style provides the framework to develop, deploy, and maintain microservices architecture diagrams and services independently

_Microservices architecture_ is often compared to service-oriented architecture (SOA), as both have the same objective, which is to break up monolithic applications into smaller components. However, they have different approaches.

- It follows single responsibility principle, where each service has it's own job.
- Micro service architecture allows each service/component to use it's own tech stack/programming language/libraries and tools.
- These Microservices runs on a unique port number. The different ports can be mapped to a domain name.

### When fetching data from an API

React allows us to do the following, this gives us a far better UX:

Load WebPage => Render UI => API Call => Render Updated UI

### UseEffect Hook, Purpose Method Pros & Cons

The useEffect hook in React is a powerful tool that allows you to synchronize a component with an external system. It’s like having a backstage pass to React’s lifecycle events.

Purpose

- Synchronization: Use useEffect to connect your component to external systems, handle side effects, and perform cleanup tasks.
- Lifecycle Events: It can replicate the behavior of componentDidMount, componentDidUpdate, and componentWillUnmount methods.

Method

- Call useEffect at the top level of your component to declare an effect.
- Provide a setup function (your effect’s logic) as the first argument.
- Optionally, specify an array of dependencies (reactive values) as the second argument. These dependencies determine when the effect runs.
- The cleanup function (if provided) runs before the effect’s setup function on every re-render with changed dependencies.

Pros

- Fetching Data: Use effects to fetch data from APIs or databases.
- Updating State: Update component state based on previous state within an effect.
- Custom Hooks: Wrap effects in custom hooks for reusability.
- Non-React Widgets: Integrate with non-React libraries or widgets.
- Reactive Dependencies: Specify dependencies to control when the effect runs.

Cons

- Top-Level Only: You can only call useEffect at the top level of your component or your own custom hooks.
- No Loops or Conditions: Avoid using it inside loops or conditions.
- Strict Mode Behavior: In strict mode, React runs an extra development-only setup+cleanup cycle before the first real setup.

### Shimmer UI and whats it's use?

Shimmer is a temporary animation placeholder for when a service call takes time to return data and we don't want to block rendering the rest of the UI. If a smooth transition from Shimmer to content is desired, wrap the content node with a Shimmer element and use the isDataLoaded prop to trigger the transition.

It is a better way to show loading states than traditional loading indicators such as buffering and loading spinners because it provides visual feedback, reduces cognitive load, eliminates surprises, and enhances aesthetic appeal.

Shimmer UI can be implemented using different platforms and frameworks such as Flutter, Microsoft Fluent UI for Shiny, or HTML and CSS.

Shimmer effect can be implemented using conditional rendering in React.

### What's Conditional rendering?

Conditional rendering is a technique in React that allows you to display different content based on certain conditions or states. It enables you to create dynamic user interfaces that can adapt to changes in data and user interactions.

In React, you can conditionally render JSX using JavaScript syntax like if statements, &&, and ? : operators. You can return different JSX depending on a condition, conditionally include or exclude a piece of JSX, and use common conditional syntax shortcuts you’ll encounter in React codebases.

### What does it mean when we render a component?

Rendering a component in React means creating a virtual representation of the component in the browser’s memory and displaying it on the screen. When a component is rendered, React creates a virtual DOM (Document Object Model) tree that represents the component’s structure and content. This virtual DOM tree is then used to update the actual DOM tree (using a diffing algorithm), which is what the user sees on the screen.

When a component’s state or props change, React will automatically re-render the component and update the virtual DOM tree. React then compares the new virtual DOM tree with the previous one and only updates the parts of the actual DOM that have changed, resulting in a faster and more efficient update process.

### What makes react fast? TLDR: The reconciliation algirithm

React’s reconciliation algorithm is responsible for updating the DOM in response to changes in the component state. When a component’s state changes, React will re-render the component and its children. The reconciliation algorithm determines what has changed in the component tree and updates the DOM accordingly.

React uses a Virtual DOM (VDOM) to perform reconciliation. The VDOM is a lightweight in-memory representation of the actual DOM. When the state of a component changes, React compares the VDOM of the last and current states and calculates the minimum number of DOM operations required to update the actual DOM to match the current VDOM. This helps reduce the number of DOM manipulations and improve the application’s performance.

React’s reconciliation algorithm was improved with the introduction of Fiber in React 16.0. Fiber is a new reconciliation algorithm that aims to improve the performance of React applications by making the reconciliation process more efficient. It does this by allowing the reconciliation process to be broken down into smaller chunks and scheduled over multiple frames rather than being completed in a single frame. Fiber divides the reconciliation work into smaller units called “fibers”. Each fiber represents a single element in the VDOM tree, and the reconciliation process is performed on each fiber individually. This allows React to prioritize the reconciliation of certain fibers over others, depending on the importance of the updates.

### Optional chaining

Optional chaining is a feature in JavaScript that allows you to access properties of an object without having to check if the object exists first. It is represented by the ?. operator, which can be used to access a property or call a method on an object only if the object is not null or undefined

## Routing Pages and Deeper dives to Hooks

- rafce => is a vs code shorthand to create a react component blueprint (boiler code).

### useEffect and it's dependency array

- useEffect hook without a dependency array is called everytime the component renders.
- if theres an empty dependency array, useEffect is called once when the component initially renders.
- if there are elements in the dependency array, it is called when the dependency array changes.

### useState hook and what not to do

- never create state variables outside your component, hooks can only be called in the body of a component.
- it's used to create local state variables inside your components. (try to call the mon the top).
- using if, else loop or function statements to create hooks will lead to inconsistencies.

### Routing in your app

react-router-dom is a package that provides declarative routing for React web applications. It is an npm package that enables you to implement dynamic routing in a web app. It allows you to display pages and allow users to navigate them.

It facilitates component-based routing according to the needs of the app and platform. Steps for using react router dom to add routing to the project:

- create routing configuration for your project using createBrowserRouter
- provide this routing configuration as a prop to your app using routerProvider
- router provider now acts as the main component to render taking routing config as a prop.

Types of routing in web apps, Client-side routing and server-side routing are two different approaches to handling routing in web applications

- _Server-side routing_ is the traditional approach to routing, where the server handles all the routing logic. When a user clicks on a link, the server sends a new document (usually HTML) as a response. The browser discards the old webpage altogether and displays the newly downloaded one. Server-side routing is fast on page load, and you will get the exact data you requested.
- _Client-side routing_ is a newer approach to routing, where the routing logic is handled by the client-side code (usually JavaScript). When a user clicks on a link, the client-side code catches this event, detects that the URL is not an external link, and then prevents the browser from making the HTTP GET request. Instead, the client-side code downloads, processes, and displays new data for you. Client-side routing is preferred for fast routing between components, since less data is loaded on each change.

Single Page Applications uses Client side routing.

### Why not use anchor tags in react? What's the Link component in react-router-dom

Anchor tags can be used in React, but it is not recommended to use them for navigation within a web application. This is because anchor tags cause the entire page to reload, which results in the loss of the app’s current state and causes a delay for the user.

Instead, React provides the Link component from react-router-dom package, which is a declarative way of handling navigation in a web application. The Link component is converted to an anchor tag internally, but it does not cause the entire page to reload. This helps to retain the app’s current state and provides a seamless user experience.

If you want to link to a webpage outside of your React app, you can use a regular anchor tag with an href attribute. However, if you want to link to a page within your React app, it is recommended to use Link component from react-router-dom package

### Single page apps

A Single Page Application (SPA) is a web application that works within a web browser and loads just a single document. It does not need page reloading during its usage, and most of its content remains the same while only some of it needs updating.

React is often used to build SPAs because it allows developers to create reusable UI components that can be rendered dynamically without requiring a full page refresh.

### Various ways of adding images to a react component

- Using the import keyword
  - You can import an image file right in a JavaScript module e.g. import logo from './logo.png';
- Using the require keyword
  - use require function to import an image file: require('./logo.png')
- Importing SVGs directly as a React component
  - mport SVG files directly as React components, import { ReactComponent as Logo } from './logo.svg'; then use <Logo />
- Loading images directly from the network
  - using the src tag src="https://www.example.com/images/logo.png"

## Getting classy with Class based components

In React, class components were the primary way to manage state and lifecycle before the introduction of Hooks. Although function components are now preferred due to their simplicity and equivalence to class components, let’s explore how class components work.

Creating a Class Component:

- Class components are defined using JavaScript classes that extend React.Component.
- The component name must start with an uppercase letter.
- A class component includes a render() method that returns HTML elements.

Component Constructor:

- If your class component has a constructor function, it gets called when the component is initialized.
- In the constructor, you can set initial properties (and/or state) for your component.
- The super() statement ensures inheritance from the parent component (React.Component).

Lifecycle Methods:

- Class components have several lifecycle methods that allow you to perform actions at specific points in the component’s life.
- Common lifecycle methods include:

  - componentDidMount(): Called after the component is inserted into the DOM.
  - componentDidUpdate(prevProps, prevState): Called after a component’s state or props change.
  - componentWillUnmount(): Called before the component is removed from the DOM.
    Props:

- Props (short for properties) allow passing data from parent components to child components.
- Class components can access props via this.props

State Management:

- Class components can hold and manage their own state using this.state.
- State changes trigger re-rendering of the component.

Remember that while class components are still valid, function components with Hooks are now the recommended approach due to their simplicity and improved performance.

### What really happens inside a class based component

When a class based component is encountered/instantiated

- the constructor of the class is called
- then the render method is called
- then the componentDidMount is called (similar to useEffect with empty dependency array)
  - componentDidMount is used to make api calls (first render UI then make API call)
  - if the parent component is a class based component, parent componentDidMount is called only after the child componentDidMount is called.
  - when there are multiple child classes react optimises the performance by batching the render cycles of the child class components

Highly recommended to Refer: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

React component lifecycle has two phases

- render phase (pure and has no sidee effects, may be paused, aborted or restarted by react)
  - initialises class constructor, then proceeds to render the comoponent
- commit phase (can work with DOM, run side effects and schedules updates)
  - react updates DOM and refs - calls componentDidMount and componentDidUpdate

Note the following

- incase of changes to state variable or update to props is made
  - we go back to render phase and component rerenders
  - then updates the DOM and refs in the commit phase
    - and finally calls the componentDidUpdate

Another sub note here:

- for functional component, when using the useEffect hook,
- the return function of the use Effect hook is called when the component unmounts.
- We can't have the useEffect function as an async function.
  - React expects the effect function to either return nothing or a cleanup function.
  - If you return a promise, React won’t be able to handle it properly, and you might encounter unexpected behavior.
  - To use an async function, create it directly inside the useEffect callback.
  - This way, you can await the result of your async operation and then update the component state accordingly.
